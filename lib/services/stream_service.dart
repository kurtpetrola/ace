// lib/services/stream_service.dart

import 'package:firebase_database/firebase_database.dart';
import 'package:ace/models/post.dart';

class StreamService {
  final DatabaseReference _db = FirebaseDatabase.instance.ref();

  // Fetches a real-time stream of posts for a specific classroom
  Stream<List<Post>> getPostsStream(String classId) {
    // Reference to the posts node for the specific class
    final postsRef =
        _db.child('Classes/$classId/posts').orderByChild('timestamp');

    // Convert the Firebase stream of events into a stream of List<Post>
    return postsRef.onValue.map((event) {
      final postsMap = event.snapshot.value;
      List<Post> posts = [];

      if (postsMap != null && postsMap is Map) {
        // Safely decode the dynamic map from Firebase
        final Map<String, dynamic> rawData =
            Map<String, dynamic>.from(postsMap);

        rawData.forEach((key, value) {
          if (value is Map<dynamic, dynamic>) {
            // Ensure data map is properly typed for the factory constructor
            final Map<String, dynamic> postData =
                Map<String, dynamic>.from(value);
            posts.add(Post.fromJson(postData, key));
          }
        });
      }

      // Sort posts by timestamp in descending order (newest first)
      posts.sort((a, b) => b.timestamp.compareTo(a.timestamp));

      return posts;
    });
  }

  // Adds a new post to the stream for the specified class
  Future<void> createPost(String classId, String authorId, String authorName,
      String content) async {
    if (content.trim().isEmpty) {
      return Future.error('Post content cannot be empty.');
    }

    final newPost = Post(
      postId: '', // ID will be generated by Firebase push()
      authorId: authorId,
      authorName: authorName,
      content: content,
      timestamp: DateTime.now(), // Ignored by Firebase, but required for model
    );

    // Push the post to the 'posts' node under the specific class ID
    await _db.child('Classes/$classId/posts').push().set(newPost.toJson());
  }
}
