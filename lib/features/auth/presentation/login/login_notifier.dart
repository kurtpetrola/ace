// lib/features/auth/presentation/login/login_notifier.dart
// Trigger build

import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:ace/features/auth/services/student_auth_service.dart';
import 'package:ace/features/auth/services/admin_auth_service.dart';
import 'package:ace/features/auth/services/teacher_auth_service.dart';
import 'package:ace/features/auth/services/auth_service_interface.dart';
import 'package:ace/features/auth/presentation/login/login_state.dart';

part 'login_notifier.g.dart'; // Generated by Riverpod

@riverpod
class LoginNotifier extends _$LoginNotifier {
  late final AuthServiceInterface _authService;
  static const int _minPasswordLength = 6; // Firebase minimum

  // --- Initial State and Service Initialization ---
  @override
  LoginState build({UserType userType = UserType.student}) {
    // Initialize the correct service based on the UserType
    // Note: AdminAuthService and StudentAuthService are instantiated here.
    if (userType == UserType.admin) {
      _authService = AdminAuthService();
    } else if (userType == UserType.teacher) {
      _authService = TeacherAuthService();
    } else {
      _authService = StudentAuthService();
    }
    return LoginState(userType: userType);
  }

  // --- STATE MUTATORS: Clear error messages when input changes ---

  void setEmail(String value) {
    state = state.copyWith(
      email: value.trim(),
      errorMessage: '',
      emailError: null, // Clear error on change
    );
  }

  void setPassword(String pass) {
    state = state.copyWith(
      password: pass,
      errorMessage: '',
      passwordError: null, // Clear error on change
    );
  }

  void togglePasswordVisibility() {
    state = state.copyWith(isPasswordVisible: !state.isPasswordVisible);
  }

  // --- Local Validation Logic ---

  bool _validateForm() {
    String? emailError;
    String? passError;
    bool isValid = true;

    // 1. Validate Email
    if (state.email.isEmpty) {
      emailError = 'Email cannot be empty.';
      isValid = false;
    } else if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$')
        .hasMatch(state.email)) {
      emailError = 'Please enter a valid email address.';
      isValid = false;
    }

    // 2. Validate Password
    if (state.password.isEmpty) {
      passError = 'Password cannot be empty.';
      isValid = false;
    } else if (state.password.length < _minPasswordLength) {
      passError = 'Password must be at least $_minPasswordLength characters.';
      isValid = false;
    }

    // Update the state with all computed errors
    state = state.copyWith(
      emailError: emailError,
      passwordError: passError,
      // Clear generic service error if local validation fails
      errorMessage: isValid ? '' : 'Please enter all required fields.',
    );

    return isValid;
  }

  // 3. Login Execution Logic (NOW uses local validation)

  Future<bool> login() async {
    // Run local validation
    if (!_validateForm()) {
      return false;
    }

    // Set loading state
    state = state.copyWith(isLoading: true, errorMessage: '');

    try {
      // Use standardized login call for both user types
      await _authService.login(
        email: state.email,
        password: state.password,
      );

      // Success
      state = state.copyWith(isLoading: false);
      return true;
    } catch (e) {
      String message = 'An unexpected error occurred: ${e.toString()}';

      // Existing error handling logic
      final String errorStr = e.toString();
      // Logic Fix: Check the generic error string against the current UserType context
      // All services use "Wrong username or password" so checking the string alone is ambiguous.
      if (errorStr.contains('Wrong username or password')) {
        message = 'Wrong email or password.';
      } else if (errorStr.contains('network-request-failed')) {
        message = 'Network error. Check your connection.';
      }

      // Failure
      state = state.copyWith(isLoading: false, errorMessage: message);
      return false;
    }
  }

  // 4. Forgot Password Logic
  Future<bool> forgotPassword() async {
    // Basic email validation specifically for reset
    if (state.email.isEmpty) {
      state = state.copyWith(errorMessage: 'Please enter your email first.');
      return false;
    }
    if (!RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(state.email)) {
      state =
          state.copyWith(errorMessage: 'Please enter a valid email address.');
      return false;
    }

    state = state.copyWith(isLoading: true, errorMessage: '');

    try {
      await _authService.sendPasswordResetEmail(state.email);
      state = state.copyWith(isLoading: false);
      return true;
    } catch (e) {
      state = state.copyWith(
          isLoading: false,
          errorMessage: e.toString().replaceAll('Exception: ', ''));
      return false;
    }
  }
}
